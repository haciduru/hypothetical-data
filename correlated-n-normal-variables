library(corpcor)

# Vote for the error term
# This function decides whether the error term will be positive or negative 
# depending on values of x, X, R, and r. A positive error term will pull the
# value of y above the yhat (predicted value of y). A negative error term will 
# do the opposite.
# Inputs:
#	x (float) a normal variable
#	X (vector) a vector of normally distributed variable
#	R (float) correlation coefficient (targetted)
#	r (float) correlation coefficient (current)
# Returns:
# 	1 or -1
vote4e = function(x, X, R, r) {

	# If the current correlation coefficient is positive ...
	if (r > 0) {
	
		# If the size of the current correlation coefficient smaller than the target coefficient ...
		if (abs(R) > abs(r)) {
			if (x > mean(X)) {
				return(1)
			} else {
				return(-1)
			}
		# Else ...
		} else {
			if (x > mean(X)) {
				return(-1)
			} else {
				return(1)
			}
		}
	# Else ...
	} else {
		if (abs(R) > abs(r)) {
			if (x > mean(X)) {
				return(-1)
			} else {
				return(1)
			}
		} else {
			if (x > mean(X)) {
				return(1)
			} else {
				return(-1)
			}
		}
	}

}

# This function creates two normally distributed random variables that are correlated with each other. 
# Inputs:
#	n (integer) number of cases
#	r (float) bivariate correlation between the variables.
# Returns:
# 	A (n X 2) matrix
create_xy = function(n, R) {

	# Initialize the first variable.
	X = round(matrix(rnorm(n)), 2)
	
	# Initialize the second variable. At this time, there is perfect
	# correlation between the two variables.
	Y = X * R
	
	# The following loop adds n new cases to the data. Every time a new case is
	# added at the bottom, one case is dropped from the top. 
	for (i in 1:n) {

		# Find the linear regression equation and the current correlation coefficient.
		X = matrix(cbind(1, X), ncol=2)
		b = solve(t(X) %*% X) %*% t(X) %*% Y
		r = cor(X[,2], Y)

		# Initialize x (the first variable) for the new case. 
		x = rnorm(1)
		
		# Calculate the predicted value of y (the second variable) based on the regression equation.
		y = b[1] + b[2] * x + e

		# Get a random normal value to add as the error term.
		e = vote4e(x, X, R, r) * abs(rnorm(1))

		# Add the new x and y values to the bottom of the dataset.
		# Also, drop the first row of the dataset.
		X = matrix(X[,2])
		X = rbind(matrix(X[-1]), matrix(x))
		Y = rbind(matrix(Y[-1]), matrix(y))
		
	}
	
	return(cbind(X, Y))

}

create_xyz = function(n, Rs) {

	data = create_xy(1000, Rs[1,2])

	k = 2
	while (k < ncol(Rs)) {
	
		k = k + 1
		pRs = cor2pcor(Rs[,1:k][1:k,])

		Yhat = 0
		for (i in 1:(k-1)) {
			Yhat = Yhat + data[,i] * pRs[i,k]
		}
		data = cbind(data, matrix(Yhat))

		i = 0
		while (i < nrow(data)) {
			i = i + 1
			e = abs(rnorm(1))
			ehat = 0
			j = 0
			while (j < (k-1)) {
				j = j + 1
				ehat = ehat + vote4e(data[i,j], data[,j], Rs[j,k], cor(data[,j], data[,k]))
			}
			data[i,k] = data[i,k] + ehat * e
		}

	}
	
	return(data)
}
